# 方法的调用

​	在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

（1）静态链接：

​	当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

（2）动态链接：

​	如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

​	

​	对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

（1）早期绑定（静态链接）：

​	早期绑定就是被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

（2）晚期绑定（动态链接）：

​	如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类绑定相关方法，这种绑定方式也被称之为晚期绑定。



​	早期面向过程的高级语言只支持早期绑定。	

​	随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就是具备早期绑定和晚期绑定两种绑定方式。

​	Java中任何一个普通的方法其实都具备虚函数的特征，他们相当于c++语言中的虚函数（c++中则需要使用关键字virtual来显示定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以用关键字final来标记这个方法（被标记的方法，子类无法继承）。



（1）非虚方法（早期绑定、静态链接）：

​	如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变得，这样的方法称为非虚方法。

​	静态方法、私有方法、final方法、实例构造器、显示调用父类方法都是非虚方法。

（2）虚方法（晚期绑定、动态链接）：

​	如果方法在编译期就无法确定，称为虚方法。

​	对象的多态性引申出的虚方法。



JVM方法调用指令：

（1）invokestatic（非虚方法）：

​	调用静态方法。

（2）invokespecial（非虚方法）：

​	调用构造方法（<init>）、私有、显示调用父类方法。

（3）invokevirtual（非虚方法）：

​	调用使用final关键字修饰的方法时。

（4）invokevirtual（虚方法）：

​	调用所有的虚方法时。

（5）invokeinterface（非虚方法）：

​	调用接口方法。

（6）invokedynamic：

​	动态调用指令。

​	invokestatic、invokespecial、invokevirtual、invokeinterface四条指令固化在JVM内部，方法的调用执行不可人为干预。

​	invokedynamic指令则支持由用户确定方法版本。



invokedynamic指令：

（1）JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。

（2）但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。

（3）Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规范的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。

（1）静态类型语言和动态类型语言

​	动态类型语言和静态类型语言的区别就在于对类型的检查是在编译器还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。

​	静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量的类型信息，变量没有类型信息，变量值才有有类型信息。

```python
# python的变量是没有类型的，而170.5是浮点型，所以这个height是浮点型
height = 170.5
```



# 对象的分配过程

​	为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所有还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

（1）new的对象先放在Eden区；

（2）当Eden区空间满时，程序有需要创建对象，就会触发垃圾回收（YGC/Minor GC）,将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区；

（3）然后将Eden区中的幸存对象移动到Surviver0区，且每个对象都设置有一个计数器，并对计数器+1；

（4）当Eden区空间再次满时，再次触发垃圾回收（YGC/Minor GC）,对Eden区和Surviver0区的全部对象进行回收，如果没有被回收，那么幸存下来的Eden区对象和Surviver0区对象都移动到Surviver1区（这时的Surviver1区称为to区，Surviver0区称为from区），且每个对象的计数器+1；

（5）再次触发垃圾回收（YGC/Minor GC），重新移动到Surviver0区（这时的Surviver0区称为to区，Surviver1区称为from区）计数器+1；接着再去Surviver1区计数器+1，如此反复；

（6）当有对象的计数器到达默认次数15时，就会提升（Promotion）到Tenure区（老年区）；

​	可以设置参数：-XX:MaxTenuringThreshold=[N]进行设置

![image-20220915164654987](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220915164654987.png)

![image-20220915165222210](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220915165222210.png)

总结：

（1）针对幸存者S0，S1区，复制之后有交换，谁空谁是to；

（2）关于垃圾回收（YGC/Minor GC），频繁在新生区收集，很少在老年区收集，几乎不在永久区/元空间收集；

上面是对象分配的一般过程，存在两个特殊方式：

（1）当新的对象在Eden分配不了时（此时Eden是空的），FGC判断老年区是否能放得下，放得下会在老年区进行分配空间，放不下如果JVM没有设置动态扩容参数，会报OOM错误；

（2）当Eden的幸存对象要放入Surviver区时，Minor GC会进行判断是否能分配空间，不能分配空间会直接提升到老年区；



# JVM调优工具

（1）JDK命令行

（2）Eclipse：Memory Analyzer Tool

（3）Jconsole

（4）VisualVM

（5）Jprofiler

（6）Java Flight Recorder

（7）GCViewer

（8）GC Easy



# 堆空间常用的JVM参数

-XX:+PrintFlagsInitial：查看所有的参数的默认初始值。

-XX:+PrintFlagsFinal：查看所有的参数的最终值。

-Xms：初始堆空间内存（默认为物理内存的1/64）。

-Xmx：最大堆空间内存（默认为物理内存的1/4）。

-Xmn：设置新生代的大小。

-XX:NewRatio：配置新生代与老年代在堆结构的占比。

-XX:SurvivorRatio：设置新生代中Eden和Surviver空间比例。

-XX:MaxTenuringThreshold：设置新生代对象的最大提升阙值。

-XX:+PrintGCDetails：输出详细的GC处理日志。

-XX:HandlePromotionFailure：是否设置空间分配担保。



# 堆是分配对象存储的唯一选择吗？

​	在《深入理解Java虚拟机》中关于Java堆内存在有这样一段描述：随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这就是最常见的堆外存储技术。

​	此外，基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。



# 逃逸分析

（1）如何将堆上的对象分配到栈，需要使用逃逸分析手段。

（2）这是一种可以有效减少Java程序中同步负载和内存堆分配压力的函数全局数据流分析算法。

（3）通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否将这个对象分配到堆上。

（4）逃逸分析的基本行为就是分析对象动态作用域：

​		当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。

​		当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如，作为调用参数传递到其他地方中。

```java
public class Escape{
    
    /// 对象sb发生了逃逸
    public static StringBuffer createS1(String s1, String s2){
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb;
    }
    
    /// 对象sb没有逃逸
    /// ToString()方法内部new String();
    public static String createS2(String s1, String s2){
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb.ToString();
    }
    
    /// 成员变量
    public Escape e;
    
    /// Escape实例对象发生了逃逸
    public Escape getInstance(){
         if(e == null)
             e = new Escape();
        return e;
    }
    
    /// 为成员变量赋值，Escape实例对象发生了逃逸
    public void setE(){
        this.e = new Escape();
    }
    
    /// Escape实例对象没有逃逸
    public void sueE(){
        Escape e = new Escape();
    }
    
    /// 引用成员变量的值，发生逃逸
    public void sueE(){
        Escape e = getInstance();
    }
}
```

参数设置：

（1）在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。

（2）如果使用比较早版本，开发人员则可以通过：

​		选项【-XX:+DoEscapeAnalysis】显示开启逃逸分析。

​		通过选项【-XX:+PrintEscapeAnalysis】查看逃逸分析的筛选结果。



# 逃逸分析下代码优化

（1）栈上分配

​	将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆中分配。

（2）同步省略

​	如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步；

```java
public class Escape{
    /// obj为逃逸
    /// 加锁，没有意义；枷锁甚至会牺牲性能
    public void syn(){
        Object obj = new Object();
        synchronized(obj){
            System.out.printLn(obj);
        }
    }
}
```

```java
public class Escape{
    /// 代码优化，同步省略
    public void syn(){
        Object obj = new Object();
        System.out.printLn(obj);
    }
}
```

（3）分离对象或标量替换

​	标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为它可以分解成其他聚合量和标量。

​	在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

```java
public class Escape{
    /// 未被优化之前
    public void scalar(){
        Point p = new Point(1, 2);
    }
    
    private class Point{
        private int x;
        private int y;
                
        public Point(int x, int y){
           this.x = x;
           this.y = y;
        }
    }
}
```

```java
public class Escape{
    /// 被标量替换优化之后
    public void scalar(){
        int x = 1;
        int y = 2;
    }
    
    private class Point{
        private int x;
        private int y;
        
        public Point(int x, int y){
           this.x = x;
           this.y = y;
        }
    }
}
```



# 栈、堆、方法区的交互关系

```java
public StackHeapMethod{
    public void sHM(){
        /// Object类的信息放在方法区
        /// 变量obj放在虚拟机栈->栈帧->局部变量表（本地变量表）
        /// new Object()放在堆
       	Object obj = new Object();
    }
    
}
```

![image-20220919161043279](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220919161043279.png)

补充：局部变量表（本地变量表），最基本的存储单元是Slot；long和double则占用两个Slot；



# 创建对象的步骤

（1）判断对象对应的类是否加载、链接、初始化；

（2）为对象分配内存；

（3）处理并发问题；

​	第一种：采用CAS配上失败重试保证更新的原子性；

​	第二种：每个线程先分配一块TLAB；

（4）默认初始化属性；

（5）设置对象的对象头；

（6）执行init方法进行显示初始化；



# 对象的内存分布

![image-20220921104307404](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220921104307404.png)



# 垃圾回收算法

主要分为两个阶段，标记阶段和清除阶段。

标记阶段的算法主要有：

（1）引用计数算法

（2）可达性分析算法（java使用的算法）

清除阶段的算法主要有：

（1）标记清除算法

（2）复制算法

（3）标记压缩算法

------

## 引用计数算法

（1）引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况；

（2）对于一个对象A，只要任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收；

优点：

（1）实现简单，垃圾对象便于辨识；

（2）判定效率高，回收没有延迟性；

缺点：

（1）它需要单独的字段存储计数器，增加了存储空间的开销（这无关紧要，毕竟只存储一个计数器）；

（2）每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销；

（3）引用计数器有一个严重的问题，即无法处理循环引用情况。这是一条致命缺陷，导致Java的垃圾回收器没有使用这类算法。

![image-20220922144940189](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220922144940189.png)

------

## 可达性分析算法

也叫：根搜索算法、追踪性垃圾收集。

（1）【GC Roots】根集合就是一组必须活跃的引用；

（2）根据【GC Roots】为起点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达；

（3）使用可达性分析算法之后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（reference chain）；

（4）如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。

（5）在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象；

![image-20220922160050561](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220922160050561.png)

GC Roots包括以下几类元素：

（1）虚拟机栈中引用对象

​	方法中的参数、局部变量等；

（2）本地方法栈内JNI引用对象

（3）方法区中类变量（静态变量，JDK7以后都在堆中）引用的对象

（4）方法区中常量引用的对象（JDK7以后都在堆中）

​	字符创常量池里的引用；

（5）所有被同步锁synchronized持有的对象

（6）Java虚拟机内部引用

​		基本数据类型对应的Class对象，一些常驻的异常对象，系统类加载器；

（7）反应java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

​	除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如分代收集和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。	



注意：

（1）如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。

（2）这点也是导致GC进行时必须【Stop The World】的一个原因。

​	即使是号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。



## 对象的finalization机制

（1）Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑；

（2）当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法；

（3）finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件，套接字和数据库连接等；

（4）永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括：

​	在finalize()时可能会导致对象复活；

​	finalize()方法的执行时间是没有保障的，它完全是由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会；

​	一个糟糕的finalize()会严重影响GC的性能；

（5）由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态；

​	可触及状态：从根节点开始，可以到达这个对象（可达性分析算法）；

​	可复活状态：对象的所有引用都被释放，但是对象有可能在finalize()中复活；

​	不可触及状态：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次；



具体过程：

判断一个对象objA是否可以回收，至少要经历至少两次标记过程。

（1）如果对象objA到【GC Roots】没有引用链，则进行第一次标记；

（2）进行筛选，判断此对象是否有必要执行finalize()方法；

​	如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为"没有必要执行"，objA被判定位不可触及的。

​	如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到【F-Queue】队列中，由虚拟机自动创建的、低优先级的finalize线程触发其finalize()方法执行。

​	finalize()方法是对象逃脱死亡的最后机会，稍后GC会对【F-Queue】队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，objA对象再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。



## 标记清除算法

背景：

​	标记清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Liso语言。

执行过程：

​	当堆的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。

（1）标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象头（header）中记录为可达对象。

（2）清除：collector对堆内存从头到尾进行线性的遍历（对全部对象进行遍历），如果发现某个对象在其header中没有标记可达对象，则将其回收。

![image-20220923144233196](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220923144233196.png)

​	产生了很多不连续空闲空间，称之为内存碎片； 当有大对象需要分配内存又找不到足够大的连续空闲内存进行分配，会报OOM。

​	注意：何为清除？这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。



## 复制算法

背景：

​	为了解决标记清除算法在垃圾收集效率方面的缺陷，M.J.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集齐CALISP Carbage Collector Algorithm Using Serial Secondary Storage”。M.LMinsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。

核心思想：

​	将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

![image-20220923150150522](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220923150150522.png)

优点：

（1）没有标记和清除过程，实现简单，运行高效；

（2）复制过去之后保证空间的连续性，不会出现“碎片”问题；

缺点：

（1）需要两倍的内存空间；

（2）GC需要维护对象引用关系，当存活的对象位置发生改变时，需要重新把新的地址重新赋值给对象引用。

（3）特别是在垃圾对象不多时，却要把大量的存活对象复制移动到一块新的内存，这是消耗很大的时间。



## 标记压缩算法

背景：

​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法,由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。

​	标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark - compact)算法由此诞生。

​	1970年前后，G.L.Steele .c. J. Chene和D.S. wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。

执行过程:
	（1）第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象；
	（2）第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

![image-20220923153216146](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220923153216146.png)

​	标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法。
​	二者的本质差异在于标记-清除算法是一种非移动式的回收算法,标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。
​	可以看到，标记的存活对象将会被整理按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

优点:
（1）消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
（2）消除了复制算法当中，内存减半的高额代价。

缺点:
（1）从效率上来说，标记-整理算法要低于复制算法。
（2）移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。·移动过程中，需要全程暂停用户应用程序。即:STW



## 分代收集算法

（1）年轻代

年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。

采用【复制算法】。

（2）老年代

老年代的特点：区域较大，对象的生命周期长、存活效率高，回收不及年轻代频繁。

一般是由【标记清除】和【标记压缩】算法的混合使用。



​	HotSpot中的CMS回收器为例，CMS是基于【Mark-Sweep】实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于【Mark-Compact】算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。



## 增量收集算法

为了解决：Stop The World

基本思想：

（1）如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么可以让垃圾收集线程和应用线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

（2）总的来说，增量收集算法的基础仍是传统的【标记清除】和【复制算法】。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分段的方式完成标记清除和复制工作。



## 分区算法

为了解决：Stop The World

（1）一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

（2）【分代算法】将按照对象的生命周期长短划分成两个部分，【分区算法】将整个堆空间划分成连续的不同小区间。

（3）每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。



# System.gc()的理解

（1）在默认情况下，通过System.gc()或者RunTime.getRuntime().gc()的调用，会显示触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。

（2）然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。

（3）JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。



# 内存泄漏

Memory Leak

只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。

例子：

（1）单例模式持有外部对象的引用，那么这个外部对象是不能被回收，则会造成内存泄漏的产生。

（2）数据库连接，网络连接和io连接必须手动关闭，否则不能被回收，也会造成内存泄漏的产生。



# STW

Stop The World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

（1）可达性分析算法中枚举根节点（GC Roots）是导致停顿的一个原因。

（2）被STW中断的应用线程会在GC完成之后恢复，频繁中断会有卡顿感觉，所以我们需要减少STW的发生。



总结：

（1）STW事件和采用哪款GC无关，所有的GC都有这个事件。

（2）哪怕是G1也不能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。

（3）STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。

（4）开发中不要用System.gc();会导致STW的发生。



# 并发和并行

​	并发，指的是多个事情，在同一时间段内同时发生，多个任务之间是互相抢占资源。

​	并行，是的是多个事情，在同一时间点上同时发生，多个任务之间是不互相抢占资源。



# 安全点和安全区域

## 安全点

​	程序执行时并非在所有地方都能停顿下来开始GC（为了高性能执行），只有在特定的位置才能停顿下来开始GC，这些位置称为安全点（Safe Point）。

​	Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如【方法调用】、【循环跳转】、【异常跳转】等。

执行过程

（1）抢先式中断（目前没有虚拟机采用）

​	首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

（2）主动式中断

​	设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。



## 安全区域

​	Safe Point机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候？例如程序处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起。JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。

​	执行过程

（1）当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。

（2）当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。



# 引用

​	强引用（Strong Reference），只要引用关系还存在，垃圾收集器就不会回收被引用的对象。

​	软引用（Soft Reference），引用关系存在且内存足够下不会被回收；引用关系存在且内存不足够下会被回收。

​	弱引用（Weak Reference），不论内存空间是否足够，下一次垃圾收集器工作时，都会被回收。

​	虚引用（Phantom Reference），一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得对象的实例。为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。

​	终结器引用（Final Reference）（模糊）。

## 强引用

（1）强引用可以直接访问目标对象。

（2）强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM错误，也不会回收强引用指向对象。

（3）强引用可能导致内存泄漏。

## 软引用

代码实现

```java
// 方式一
// 声明强引用
Object obj = new Object();
// 声明软引用
SoftReference<Object> sf = new SoftReference<Object>(obj);
// 销毁强引用
obj = null;
// 获取实例对象强引用
// 如果对象实例已经被回收的话是null
Object obj2 = sf.get();

// 方式二
// 声明软引用
SoftReference<Object> sf = 
    new SoftReference<Object>(new Object());
```

## 弱引用

```java
// 方式一
// 声明强引用
Object obj = new Object();
// 声明弱引用
WeakReference<Object> wf = new WeakReference<Object>(obj);
// 销毁强引用
obj = null;
// 获取实例对象强引用
// 如果对象实例已经被回收的话是null
Object obj2 = wf.get();

// 方式二
// 声明弱引用
WeakReference<Object> wf = new WeakReference<Object>(new Object());
```

## 虚引用

无法单独使用，也无法通过虚引用来获取被引用对象。

```java
// 声明强引用
Object obj = new Object();
// 声明【引用队列】
RefenrenceQueue pq = new ReferenceQueue();
// 声明虚引用
PhantomReference<Object> pf = 
    new PhantomReference<Object>(obj， pq);
// 销毁强引用
obj = null;
```

## 终结器引用

（1）它用以实现对象的finalize()方法，也可以称为终结器引用。

（2）无需手动编码，其内部配合引用队列使用。

（3）在GC时，终结器引用入队，由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。



# 垃圾收集器分类

（1）按线程分（指的是垃圾回收器的线程），分为【串行垃圾回收器】和【并行垃圾回收器】。

（2）按工作模式分，分为【并发垃圾回收器】和【独占式垃圾回收器】。

​	并发垃圾回收器与工作线程交替工作；

​	独占式垃圾回收器，停止工作线程，直到垃圾回收完成结束；

（3）按碎片处理方式分，分为【压缩式垃圾回收器】和【非压缩式垃圾回收器】。

​	压缩式垃圾回收器，对对象进行整理，消除回收后的碎片；

​	非压缩式垃圾回收器，不整理碎片；

（4）按工作内存区间分，分为【年轻代垃圾回收器】和【老年代垃圾回收器】。

​	

# 评估GC的性能指标

（1）【吞吐量】：用户程序的时间 / 总运行时间（用户程序时间 + 内存回收的时间）。

（2）垃圾收集开销：吞吐量的补数，1 - 吞吐量（内存回收的时间 / 总运行时间）。

（3）【停顿时间】：执行垃圾收集时，程序的工作线程被停顿的时间。

（4）收集频率：垃圾回收的频率。

（5）内存占用：Java堆区所占的内存大小。

（6）快速：一个对象从诞生到被回收所经历的时间。



现在标准：在最大吞吐量优先的情况下，降低停顿时间。



# GC介绍

## Serial GC

Serial GC、Serial Old GC

（1）Serial GC是最基本、历史最悠久的垃圾回收器了。JDK1.3之前唯一的选择。

（2）Serial GC运行在新生代，使用复制算法、串行回收（只有一个回收线程在运行）、STW机制。

（3）Serial Old GC运行在老年代，使用标记-压缩算法、串行回收（只有一个回收线程在运行）、STW机制。

（4）这个收集器是一个单线程的收集器，更加适用于单核的，效率高效的。



## ParNew GC

（1）ParNew GC是Serial GC的多线程版本。

（2）ParNew GC运行在新生代，使用复制算法、多线程并行（单核数并发，多核并行）、STW机制。

（3）一般，ParNew GC默认的线程数与核数相同。



## Parallel GC

Parallel GC、Parallel Old GC

（1）Parallel GC运行在新生代，使用复制算法、多线程并行（单核数并发，多核并行）、STW机制。

（2）可控制的吞吐量和自适应调节策略。

（3）Parallel Old GC运行在老年代，使用标记-压缩算法、多线程并行（单核数并发，多核并行）、STW机制。

（4）吞吐量优先。



## CMS GC

（1）JDK1.5推出CMS（Conrurrent Mark Sweep）。

（2）尽可能缩短用户线程的停顿时间。

（3）CMS运行在老年代，使用标记-清除算法（会产生内存碎片）、STW机制。

（4）工作流程

​	初始标记：STW，仅仅标出ROOTS直接关联的对象。

​	并发标记：与用户线程并发执行，从直接关联的对象标记整个对象图过程。

​	重新标记：STW，由于上个阶段和用户线程一起并发执行，有些不确定是否是垃圾的对象，重新确定。

​	并发清除：与用户线程并发执行，清除垃圾；没有进行内存整理；

## G1

Garbage First（垃圾优先），垃圾越多的（Region）回收的价值越大。

（1）G1是JDK9以后的默认垃圾回收器。

（2）G1采用全新的分区算法（同时也存在着分代：年轻代和老年代）。

​	分区Region：

![image-20221013172729267](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221013172729267.png)

humongous：主要存放大对象，如果超过1.5个Region，就放在H区。

（3）G1的回收过程

​	A : 年轻代GC（Young GC）；

​	过程：扫描根-更新RSet-处理RSet-复制对象-处理引用

![image-20221013174826568](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221013174826568.png)

采用：复制算法，把年轻代的存活对象复制到空闲Region分区空间中；如果对象的分代年龄到达了阙值，就晋升到老年代中。

注意：年轻代的回收过程还有个Remembered Set机制，主要考虑到老年代有引用年轻代对象的问题。



​	B: 老年代并发（回收线程和用户线程并发）标记过程（Concurrent Marking）；

​	过程：初始化标记-根区域扫描（Root Region Scanning）-并发标记（Concurrent Marking）-再次标记（Remark）-独占清理（cleanUp，STW）-并发清理完全空闲的Region



​	C: 混合回收（Mixed GC）；

​	当越来越多的对象晋升到老年代oldregion时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器器，即Mixed GC，该算法并不是一个0ld GC，除了回收整个Young
Region，还会回收一部分的0ld Region。 这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些0ld Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。



​	D: 如果G1的回收失败则启动Full GC（单线程、独占式、高强度）；

​	G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行(Stop-The-world），使用单线程的内存回收算法进行垃圾回收,性能会非常差，应用程序停顿时间会很长。
​	要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢?比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full GC，这种情况可以通过增大内存解决。
导致G1Full GC的原因可能有两个:

​	1. Evacuation的时候没有足够的to-space来存放晋升的对象;

​	2. 并发处理过程完成之前空间耗尽。