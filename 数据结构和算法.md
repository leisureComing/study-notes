# 1 数据结构和算法

什么是算法

在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。

什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用目的是高效地访问和修改数据。数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。

什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。常见的时间复杂度包括：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)等。

什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作S(n)=O(f(n))。常见的空间复杂度包括：O(1) < O(n) < O(n^2)等。



# 2 数据结构

数据结构的操作无非是增删改查四种情况。



## 2.1 数组

顺序存储在内存中。

数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。

数组元素是顺序存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

总的来说，数组适合在读操作多、写操作少的场景。



## 2.2 链表

随机存储在内存中。

在查找元素时，只能从头节点（需要维护一个头节点）开始向后一个一个节点逐一查找。

链表的优势在于能够灵活地进行插入和删除操作，如果需要频繁插入、删除元素，用链表更合适一些。



------



查找

在查找元素时，只能从头节点开始向后一个一个节点逐一查找

------

更新节点

如果不考虑查找节点的过程，链表的更新过程会像数组一样简单，直接把旧数据替换成新数据即可。

------

插入节点

尾部插入

把最后一个节点的next指针指向新插入的节点即可。



头部插入

第一步，把新节点的next指针指向原先的头节点。

第二步，把新节点变为链表的头节点。



中间插入

第一步，新节点的next指针指向插入位置的节点。

第二步，插入位置前置节点的next指针，指向新节点。

------

删除元素

尾部删除

把倒数第二个节点的next指针指向空即可。



头部删除

把链表的头节点设置为原先头节点的next指针所指向的节点即可。



中间删除

把要删除节点的前置节点的next指针，指向要删除元素的next即可



## 2.3 物理结构和逻辑结构

`物理结构`在内存中实实在在的存储结构。

`逻辑结构`逻辑结构是抽象概念，它依赖于物理结构而存在。

常用的数据结构有很多，但大多数都以数组和链表作为存储方式。数组和链表可以被看作数据存储的`物理结构`。



`物理结构`

顺序存储结构：数组

链式存储结构：链表

------

`逻辑结构`（物理实现可以是数组或链表）

线性结构：顺序表、栈、队列

非线性结构：树、图



## 2.4 栈

​	栈式一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（FILO）。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。

​	入栈和出栈只会影响最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是链表实现，入栈、出栈的时间复杂度都是O(1)。

数组实现

| 栈底 |      |      | 栈顶 |      |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |



链表实现

表格没能很好的表现出链表，简单体现一下

| 栈底 | 栈底 |      |      |      |      | 栈顶 | 栈顶 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 3    | next | 2    | next | 5    | next | 6    | next |      |      |



------



栈的应用

栈的输顺序和输入顺序相反，所以栈通常用于对历史的回溯，也就是逆流而上追溯历史。

例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。

栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地返回上一级或更上一级页面。



## 2.5 队列

​	队列是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。队列的出口端叫作队头（front）,队列的入口端叫作队尾（rear）。



链表实现

表格没能很好的表现出链表，简单体现一下

| 队头 | 队头 |      |      |      |      | 队尾 | 队尾 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 3    | next | 2    | next | 5    | next | 6    | next |      |      |



------



数组实现

用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的下一个位置。

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |



3和2进行出队操作

|      |      | 队头 |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |

如果像这样不断出队，队头左边的控件失去作用，队列的容量是越来越小。

所以数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。



循环队列

在数组不做扩容的前提下，我们可以利用已出队元素留下的空间，让队尾指针重新指回数组首位。

一直到`（队尾下标 + 1） % 数组长度 = 队头下标`时,代表此队列真的已经满了。需要注意的是，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。



------



队列的应用

队列的输出顺序和输入顺序相同，所以队列通常用于对历史的回放，也就是按照历史顺序，把历史重演一遍。

例如多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。

再如网络爬虫实现网站捉取时，也是把待捉取的网站URL存入队列中，再按照存入队列的顺序来依次捉取和解析的。



双端队列

这种数据结构，可以说综合了栈和队列的优点，对双端队列来说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。



优先队列

它不遵循先入先出，而是谁的优先级最高，谁先出队。优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现的。



## 2.6 哈希表

哈希表也叫散列表，是存储Key-Value映射的集合。对于某一个Key，哈希表可以在接近O(1)的时间内进行读写操作。哈希表通过哈希函数（每种语言的实现的哈希函数会有差别）实现Key（每个对象都有一个hash值进行对应）和数组下标的转换，通过`开放寻址法`和`链表法`来解决哈希冲突。



放开寻址法

当一个Key通过哈希函数获取对应的数组下标已被占用时，我们可以另谋高就，寻找下一个空当位置（寻址方式有很多种，并不一定找当前元素的后一个元素）。



链表法

哈希表数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入对应的链表中即可。