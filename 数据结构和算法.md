# 1 数据结构和算法

什么是算法

在计算机领域里，算法是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。

什么是数据结构

数据结构是数据的组织、管理和存储格式，其使用目的是高效地访问和修改数据。数据结构包含数组、链表这样的线性数据结构，也包含树、图这样的复杂数据结构。

什么是时间复杂度

时间复杂度是对一个算法运行时间长短的量度，用大O表示，记作T(n)=O(f(n))。常见的时间复杂度包括：O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)等。

什么是空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，用大O表示，记作S(n)=O(f(n))。常见的空间复杂度包括：O(1) < O(n) < O(n^2)等。



# 2 数据结构

数据结构的操作无非是增删改查四种情况。



## 2.1 数组

顺序存储在内存中。

数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。

数组元素是顺序存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

总的来说，数组适合在读操作多、写操作少的场景。



## 2.2 链表

随机存储在内存中。

在查找元素时，只能从头节点（需要维护一个头节点）开始向后一个一个节点逐一查找。

链表的优势在于能够灵活地进行插入和删除操作，如果需要频繁插入、删除元素，用链表更合适一些。



------



查找

在查找元素时，只能从头节点开始向后一个一个节点逐一查找

------

更新节点

如果不考虑查找节点的过程，链表的更新过程会像数组一样简单，直接把旧数据替换成新数据即可。

------

插入节点

尾部插入

把最后一个节点的next指针指向新插入的节点即可。



头部插入

第一步，把新节点的next指针指向原先的头节点。

第二步，把新节点变为链表的头节点。



中间插入

第一步，新节点的next指针指向插入位置的节点。

第二步，插入位置前置节点的next指针，指向新节点。

------

删除元素

尾部删除

把倒数第二个节点的next指针指向空即可。



头部删除

把链表的头节点设置为原先头节点的next指针所指向的节点即可。



中间删除

把要删除节点的前置节点的next指针，指向要删除元素的next即可



## 2.3 物理结构和逻辑结构

`物理结构`在内存中实实在在的存储结构。

`逻辑结构`逻辑结构是抽象概念，它依赖于物理结构而存在。

常用的数据结构有很多，但大多数都以数组和链表作为存储方式。数组和链表可以被看作数据存储的`物理结构`。



`物理结构`

顺序存储结构：数组

链式存储结构：链表

------

`逻辑结构`（物理实现可以是数组或链表）

线性结构：顺序表、栈、队列

非线性结构：树、图



## 2.4 栈

​	栈式一种线性逻辑结构，可以用数组实现，也可以用链表实现。栈包含入栈和出栈操作，遵循先入后出的原则（FILO）。最早进入的元素存放的位置叫作栈底，最后进入的元素存放的位置叫作栈顶。

​	入栈和出栈只会影响最后一个元素，不涉及其他元素的整体移动，所以无论是以数组还是链表实现，入栈、出栈的时间复杂度都是O(1)。

数组实现

| 栈底 |      |      | 栈顶 |      |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |



链表实现

表格没能很好的表现出链表，简单体现一下

| 栈底 | 栈底 |      |      |      |      | 栈顶 | 栈顶 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 3    | next | 2    | next | 5    | next | 6    | next |      |      |



------



栈的应用

栈的输顺序和输入顺序相反，所以栈通常用于对历史的回溯，也就是逆流而上追溯历史。

例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。

栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地返回上一级或更上一级页面。



## 2.5 队列

​	队列是一种线性逻辑结构，可以用数组实现，也可以用链表实现。队列包含入队和出队操作，遵循先入先出的原则（FIFO）。队列的出口端叫作队头（front）,队列的入口端叫作队尾（rear）。



链表实现

表格没能很好的表现出链表，简单体现一下

| 队头 | 队头 |      |      |      |      | 队尾 | 队尾 |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 3    | next | 2    | next | 5    | next | 6    | next |      |      |



------



数组实现

用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的下一个位置。

| 队头 |      |      |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |



3和2进行出队操作

|      |      | 队头 |      | 队尾 |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 2    | 5    | 6    |      |

如果像这样不断出队，队头左边的控件失去作用，队列的容量是越来越小。

所以数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。



循环队列

在数组不做扩容的前提下，我们可以利用已出队元素留下的空间，让队尾指针重新指回数组首位。

一直到`（队尾下标 + 1） % 数组长度 = 队头下标`时,代表此队列真的已经满了。需要注意的是，队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。



------



队列的应用

队列的输出顺序和输入顺序相同，所以队列通常用于对历史的回放，也就是按照历史顺序，把历史重演一遍。

例如多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。

再如网络爬虫实现网站捉取时，也是把待捉取的网站URL存入队列中，再按照存入队列的顺序来依次捉取和解析的。



双端队列

这种数据结构，可以说综合了栈和队列的优点，对双端队列来说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。



优先队列

它不遵循先入先出，而是谁的优先级最高，谁先出队。优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现的。



## 2.6 哈希表

哈希表也叫散列表，是存储Key-Value映射的集合。对于某一个Key，哈希表可以在接近O(1)的时间内进行读写操作。哈希表通过哈希函数（每种语言的实现的哈希函数会有差别）实现Key（每个对象都有一个hash值进行对应）和数组下标的转换，通过`开放寻址法`和`链表法`来解决哈希冲突。



放开寻址法

当一个Key通过哈希函数获取对应的数组下标已被占用时，我们可以另谋高就，寻找下一个空当位置（寻址方式有很多种，并不一定找当前元素的后一个元素）。



链表法

哈希表数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入对应的链表中即可。



## 2.7 树

树的定义如下：

树（tree）是n（n>=0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。

1、有且仅有一个特定的称为根的节点。

2、当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。

```shell
# 根节点（root）
# 叶子节点（leaf）
# 父节点（parent）
# 孩子节点（child）
# 兄弟节点（sibling）
```

树的最大层级数，称为树的高度或深度。



## 2.8 二叉树

二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点。

```shell
# 左孩子（left child）
# 右孩子（right child）
```



### 2.8.1 满二叉树

一个二叉树的所有非叶子节点都存在左孩子和右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树（满二叉树的每一个分支都是满的）。



### 2.8.2 完全二叉树

对于有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树（只需要保证最后一个节点之前的节点都齐全即可）。



### 2.8.3 物理实现

链式存储和数组。



------



链式存储结构

```shell
# 存储数据的data变量
# 指向左孩子的left指针
# 指向右孩子的right指针
```

图等待补充....



------



数组存储结构

使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某个节点的左孩子或右孩子空缺，则数组的相应位置也空出来（这样设计更方便在数组中定位二叉树孩子节点和父节点）。

```shell
# 假设一个父节点的下标是parent
# 左孩子节点的下标：2*parent+1
# 右孩子节点的下标：2*parent+2

# 假设一个左孩子节点的下标是leftChild
# 父节点的下标：(leftChild-1)/2

# 假设一个右子节点的下标是rightChild
# 父节点的下标：(rightChild-2)/2
```

图等待补充....



### 2.8.4 二叉树的应用

二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行查找操作和维持相对顺序这两个方面。



------



查找

二叉查找树

在二叉树的基础上增加了以下几个条件：

```shell
# 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
# 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
# 左子树、右子树也都是二叉查找树
```

对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂就是O(logn)，和树的深度是一样的。



------



维持相对顺序

这一点仍然要从二叉查找树说起。二叉查找树要求左子树节点的值小于父节点的值，右子树节点的值大于父节点的值，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字，二叉排序树（binary sort tree）。



### 2.8.5 二叉树遍历

从节点之间位置关系的角度来看，二叉树的遍历分为4种。

```shell
# 前序遍历（根节点-左子树-右子树）
# 中序遍历（左子树-根节点-右子树）
# 后序遍历（左子树-右子树-根节点）
# 层序遍历（一层一层横向遍历各个节点）
```



从更宏观的角度来看，二叉树的遍历归结为两大类。

```shell
# 深度优先遍历（前序遍历、中序遍历、后序遍历）
# 广度优先遍历（层序遍历）
```



------



实现遍历

前序遍历、中序遍历、后序遍历使用`递归`的思路（是最自然的实现方式）和借助数据结构`栈`来实现遍历（稍微复杂）。

层序遍历借助数据结构`队列`来实现。



### 2.8.6 二叉堆

二叉堆本质上是一种完全二叉树，它分为两种类型。

```shell
# 最大堆
# 最大堆的任何一个父节点的值，都大于或等于它左孩子和右孩子节点的值

# 最小堆
# 最小堆的任何一个父节点的值，都小于或等于它左孩子和右孩子节点的值
```



------



二叉堆的自我调整

```shell
# 插入节点
# 删除节点
# 构建二叉堆
```

这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。



------



插入节点（最后一个叶子节点“上浮”）

```shell
# 当在二叉堆中插入节点时，插入位置时完全二叉树的最后一个位置。
# 新节点和父节点对比，不符合最小堆（最大堆）的性质话，于是让新节点“上浮”，和父节点交换位置
# 新节点继续和父节点比较，直到符合符合最小堆（最大堆）的性质。
```



------



删除节点（堆顶根节点“下沉”）

```shell
# 二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点
# 这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点临时补到原本堆顶的位置
# 让暂处堆顶的节点和它的左右孩子比较（最小堆中最小的节点交换位置/最大堆中最大的节点交换位置）
# 这时是叫作节点“下沉”
# 这时“下沉”的节点继续和它的左右孩子比较，直到符合符合最小堆（最大堆）的性质。
```



------



构建二叉堆

```shell
# 就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次“下沉”
# 首先从最后一个非叶子节点开始，和它的左右孩子对比中（最小堆中最小的节点/最大堆中最大的节点）则
# 非叶子节点“下沉”
# 接下来轮到下一个非叶子节点和它的左右孩子对比，直到符合符合最小堆（最大堆）的性质。
```



------



二叉堆的实现

二叉堆不是使用链式存储，而是顺序存储（数组存储）。

下标的转换公式参考`2.8.3 的数组存储结构`